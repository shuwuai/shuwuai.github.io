<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL Crash Course Part I]]></title>
    <url>%2F2017%2F12%2F06%2FMySQL-Crash-Course-Part-I%2F</url>
    <content type="text"><![CDATA[MySQL必知必会 Part I1. 主键 primary key:唯一能够区分表中每个行（订单ID 雇员ID security ID） · 任意两行都不具有相同的主键值· 每个行都必须具有一个主键值（不允许 NULL ）· 使用多个列作为主键时，所有列值的组合必须是唯一的（单个列的值可以不唯一）· 不更新主键列中的值· 不重用主键列的值· 不在主键列中使用可能会更改该的值 2. 数据库结构 row coloumnColumns 包含字段名、数据类型、是否允许 NULL、键信息、默认值以及其他信息（auto_increment–id类似字段的自动增量） 3. 检索语句 SELECT· 选择多列，列名之间加逗号 · 检索有不同值的列使用 DISTINCT 关键字，此关键字指示 MySQL 只返回不同的值。DISTINCT 关键字应用于所有列。 · 限制结果可使用 LIMIT 子句，SELECT prod_name FROM products LIMIT 5; 要得出下一个 5 行，可以指定开始行和行数，SELECT prod_name FROM products LIMIT 5,5; ==检索出来的第一行是 0 而不是 1== · MySQL 5 开始支持另一种语法 OFFSET，即 LIMIT 3,4 = LIMIT 4 OFFSET 3 · 完全限定表名与列名SELECT products.prod_name FROM crAShcourse.products; 4. 排序语句 ORDER BY· 单列排序排序列可以是 SELECT 的也可以是非 SELECT 的SELECT prod_name FROM products ORDER BY prod_name;SELECT prod_name, prod_id FROM products ORDER BY prod_price; · 多列排序SELECT prod_name, prod_id, prod_price FROM products ORDER BY prod_name, prod_id; · 升降 DESC/ASC只对关键字前的一列有效，如果要对多列进行升降排序，需要为每列指定 DESC/ASC 关键字（Dicionary 类数据库排序中，A = a，其他需要请求 DBA 帮助） · ORDER BY 需位于 FROM 后, LIMIT 需位于 ORDER BY 后5. 过滤数据语句 WHERESELECT prod_name, prod_id FROM products WHERE prod_price = 2.5; · 同时使用 ORDER BY 和 WHERE 时，ORDER BY 需要位于 WHERE 后 · 空值检查NULL 与包含 0、空字符串或仅仅包含空格不同SELECT prod_name FROM products WHERE prod_price is NULL; · 数据过滤操作符= != &lt;&gt; &lt;= &gt;= &gt; &lt; BETWEEN AND ####· AND OR 逻辑操作符AND 优先级更高，搭配 OR 使用需要圆括号SELECT prod_name, prod_price FROM products WHERE (vend_id = 1002 OR vend_id = 1003) and prod_price &gt;=10; · 操作符 OR 与 IN 相同vend_id = 1002 OR vend_id = 1003 等同于 vend_id IN (1002,1003) IN 操作符语法更清楚直观，计算次序更容易管理，执行更快，可以包含其他 SELECT 子句 · NOT 操作符，有且仅有一个功能，否定它之后跟的任何条件。MySQL 中的 NOT 语句支持对 IN、BETWEEN、EXISTS 语句取反6. 通配符过滤 LIKE· %通配符任何字符出现的任意次数，% 代表搜索中给定位置的 0 个、1 个或多个字符，但不能匹配 NULL SELECT prod_name FROM products WHERE prod_name LIKE &#39;jet%&#39;; 检索以 jet 开头、后跟任意字符的词SELECT prod_name FROM products WHERE prod_name LIKE &#39;%jet%&#39;; 检索以任意字符开头和结尾，中间包含 jet 的词 · (_)下划线通配符用途与%一样，但匹配单个字符而非多个字符，其中搜索 1 要求匹配两个通配符，因此 .5 ton anvil 不显示；与 % 能够匹配 0 个字符不同，_只能匹配一个字符，不能多也不能少 7. 正则表达式 REGEXP· 需要大小写时用 BINARYSELECT prod_name FROM products WHERE prod_name REGEXP BINARY &#39;TON&#39;; · 进行 OR 匹配用 “ | ”，多个 “ | ” 可并入多个正则表达式SELECT prod_name FROM products WHERE prod_name REGEXP &#39;anvil|et&#39;; · 匹配几个字符之一&#39;[123] ton&#39; 为 &#39;[1|2|3] ton&#39; 的缩写，不等于 &#39;1|2|3 ton&#39;匹配范围时，[0123456789] 等同于 [0-9]，同样的，[a-z] 可以匹配所有字母匹配特殊字符时，使用 \\ 进行前导，如默认情况下 &#39;.&#39; 匹配所有结果，而 &#39;\\.&#39; 只匹配含有 “.” 的记录 · 匹配多个实例需要解说一下，\\(匹配 (，[0-9] 匹配任意数字（这个例子中为 1 和 5), sticks？ 匹配 stick 和 sticks (s 后的 ？ 使 s 可选，因为 ？ 匹配它前面的任何字符的 0 次或 1 次出现，\\) 匹配)。没有 ？，匹配 stick 和 sticks 会非常困难。 分析如前所述，[:digit:] 匹配任意数字，因而它为数字的一个集合。{4} 确切地要求它前面的字符（任意数字）出现 4 次，所以 [[:digit:]] {4} 匹配连在一起的任意 4 位数字。 · 定位符：匹配 特定位置 的文本^ 文本的开始、$ 文本的结尾、[[:&lt;:]] 词的开始、[[:&gt;:]] 词的结尾 8. 创建计算字段如果想在一个字段中既显示公司名，又显示公司的地址，但这两个信息一般包含在不同的表列中。城市、州和邮政编码存储在不同的列中（应该这样），但邮件标签打印程序却需要把它们作为一个恰当格式的字段检索出来。列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。 Vendors 表包含供应商名和位置信息。假如要生成一个供应商报表，需要在供应商的名字中按照 name (location） 这样的格式列出供应商的位置。此报表需要单个值，而表中数据存储在两个列 vend_name 和 vend_country 中。此外，需要用括号将 vend_country 括起来，这些东西都没有明确存储在数据库表中。 Concat( )RTrim( ) LRrim( ) 去掉左右两边的空格使用别名：SELECT Concat(RTrim(vend_name), &#39; (&#39;, RTrim(vend_COUNTry), &#39;)&#39;) AS vend_title FROM vendors; 并不新建一个列 执行计算：SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM orderitems WHERE order_num = 20005; 可以用圆括号来限制运算符执行顺序 9. 使用数据处理函数函数没有 SQL 语句的可移植性强，使用时应做好代码注释 · 文本处理函数 MySQL 5.7 StrINg FunctionsUpper( ) 将文本转换为大写、Soundex( ) 返回文本串为描述其语音表示的字母数字模式 · 时间日期处理函数 MySQL 5.7 Data and Time Functions处理 period of time 的几种方法:SELECT cust_id, order_num FROM orders WHERE Date(order_date) BETWEEN &#39;2005-09-01&#39; AND &#39;2005-09-30&#39;;SELECT cust_id, order_num FROM orders WHERE Year(order_date) = 2005 AND Month(order_date) = 9; · 汇总函数 AVG( ) SUM( ) COUNT( ) MIN( ) MAX( )COUNT( ) 忽略 NULLMAX( ) 可以用于文本，如果数据按相应的列排序，MAX( ) 返回最后一行MIN( ) 可以用于文本，如果数据按相应的列排序，MIN( ) 返回最前面的行，并忽略 NULL 值 SUM( ) 可以用来合计计算值，忽略 NULL 值 SELECT SUM(item_price*quantity) AS total_price FROM orderitems WHERE order_num = 20005; AVG( ) 可以使用 DISTNCT 函数，只返回不同价格 produc 的价格平均值（2.5，10 只计算一个） SELECT avg(distINct prod_price) AS avg FROM products WHERE vend_id = 1003;如果指定列名，则 DISTINCT 只能用于 COUNT（ ）。DISTINCT不能用于 COUNT（*），因此不允许使用 COUNT (DISTINCT），否则会产生错误。类似地，DISTINCT 必须使用列名，不能用于计算或表达式。 组合聚集函数：SELECT 可根据需要包含多个聚集函数 · 分组数据SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id; · GROUP BY 子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。· 如果在 GROUP BY 子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。· GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。· 除聚集计算语句外，SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。· 如果分组列中具有 NULL 值，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。· GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。 WHERE 过滤行，HAVING 过滤分组SELECT cust_id ,COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2; 中，WHERE 不起作用· 分组排序 GROUP BY / ORDER BY SELECT 子句顺序 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 10. 使用子查询SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39;);SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39;)); · 作为计算字段使用子查询，需要限定列名SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customers ORDER BY cust_name; 11. 联结（Join）表· 检索的两个列分别位于两个表中，需要完全限定列名SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name, prod_name; · 笛卡儿积（cartesian product）由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 · 联结多个表SELECT prod_name, vend_name, prod_price, quantity FROM orderitems, products, vendors WHERE products.vend_id = vendors.vend_id and orderitems.prod_id = products.prod_id and order_num = 20005; · 自联结查询 products 表中供应商与商品名为 ‘DRNTR’ 相同的商品 · 外部联结 LEFT/RIGHT OUTER JOIN ON必须使用 LEFT/RIGHT 关键字指定包含所有行的表； · 使用 UNION 求两个 SELECT 语句的并集不管查询结构是否包含重复，可简化复杂语句的 WHERE 操作SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5 UNION SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002) ORDER BY vend_id, prod_price; 12. 使用全文本搜索在创建表时启用全文本搜索支持 FULLTEXT( ) . 使用查询扩展这次返回了 7 行。第一行包含词 anvils，因此等级最高。第二分析行与 anvils 无关，但因为它包含第一行中的两个词（customer 和 recommend），所以也被检索出来。第 3 行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及 anvils（按它们的产品名）。正如所见，查询扩展极大地增加了返回的行数，但这样做也增加了你实际上并不想要的行的数目。 · 布尔文本搜索包含匹配词 heavy，但 -rope 表示不包含以 rope 开头的词： `SELECT note_text FROM productnotes WHERE MATCH(note_text) AGAINST(‘heavy -rope‘ IN BOOLEAN MODE);` 匹配包含词 rabbit 和 bait 的行： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39;+rabbit +bait&#39; IN BOOLEAN MODE); 没有指定操作符，这个搜索匹配包含 rabbit 和 bait 中的至少一个词的行： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39;rabbit bait&#39; IN BOOLEAN MODE); 这个搜索匹配短语 rabbit bait 而不是匹配两个词 rabbit 和 bait： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39; &quot;rabbit bait&quot; &#39; IN BOOLEAN MODE); 匹配 rabbit 和 carrot，增加前者的等级，降低后者的等级： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39; &gt;rabbit &lt;carrot &#39; IN BOOLEAN MODE); 匹配词 safe 和 combINation，降低后者的等级： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39; +safe +(&lt; combINation) &#39; IN BOOLEAN MODE); End of Part I]]></content>
      <categories>
        <category>CodINg</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廉价，素质，人权与公权力滥用]]></title>
    <url>%2F2017%2F12%2F05%2FCheap-quality-abuse-of%20human-rights-and-public-power%2F</url>
    <content type="text"><![CDATA[中国人无疑是世界上最能隐忍的群体之一。 离开养尊处优的媒体圈子，你发现只能以穷游的方式去远方；辗转于地理学过却没走过的京九贵昆湘黔浙赣，吐槽联通出了城就傻逼的同时作为基本是孤品的一类旅客开始阅人无数。 高铁滚滚洪流之下，如今的绿皮火车自然以四海为家的农民工居多，但最明显的也只见于皖鲁之间；大多是一眼就能见生活所迫的碌碌迁徙者，间或有穿戴尚可的一级站之间的短途客，一身廉价西装工牌还没来得及摘的打工者，城镇企业家打扮腰揣几把车钥匙的生意人，与我也不清楚有没有钱的学生。虽然那扛不动蛇皮口袋的身躯着实可怜，而吐槽上了半车实实在在的民工可能偷着抽烟不容易管的列车员倒也滑稽。各地铁路局也风格迥异，以南昌职业素养最高，青岛次之，西安最糟，普天之下不得不感叹基建狂魔蛮荒的内心。 道听听到最多的莫过于我在xx呆过许多年这样的开头，虽然我经常背对他们，仍不难听出话语洋溢至脸上的走出来的自豪神情，即使如今仍不断被迫迁徙。而人群属性似乎注定了他们也有更多的弯路故事，比如我哥输掉了三轮车，我也输掉了，所以不得已出来打了几年工之类；大概都无暇顾及自己还是不是被总书记牵挂着。 更有，一家四口、期间尚有不足岁的婴儿，车厢空隙席地而睡，于是你都分不清建议其他出土文物般的人是不是该洗洗衣服再来坐车以示对别人的尊重这件事是不是政治正确。 也时常有游离于法外之地的“准传销者”，对落单的老人现场施法，以推销他们董事长十几岁自创中药企至今已治愈多少癌症的良方。 更多的，则是日常打工的家长里短，北方媳妇儿不爱洗衣服。除了男的钟爱乐福鞋，女的钟爱皮裤，不少人排斥读书教育与新事物，而对假药、封建迷信、TG都有着天真的执念。 公权力无孔不入的肆意侵入，高铁尚且每过一站布施几个红头文件，绿皮火车就干脆不考虑时宜的用抵挡不住的音量灌输所谓旅行文化，好似几年前去西安的夜车上被无数人建议过最好开小点暖气却始终一脸茫然的列车员。和谐社会，没有做“人”的机会。这是跟贫穷一样可悲的事情。 世界那么大。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>中国</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA惰性初始化]]></title>
    <url>%2F2017%2F11%2F14%2FLazy-Instantiation-of-Java%2F</url>
    <content type="text"><![CDATA[为什么要使用惰性初始化：因为类中为基本类型时，能够自动被初始化为0，但是对象引用会被初始化为null。编译器不是简单的为每一个引用创建对象创建默认对象，这一点是很有用的，因为真要那样的话，会在很多情况下增加很多开销。那么如果想初始化这些引用，就可以在代码中的很多位置进行，其中“惰性初始化”是其中的一种方式。 12345678910111213class Simple &#123; String s; public Simple(String si) &#123; s = si; &#125;//构造函数,内部为构造变量赋值 public String toString() &#123; return s; &#125; //复写 public void setString(String sstr) &#123; s = sstr; &#125;//普通函数&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Second &#123; Simple simple; String s; public Second (String si) &#123; s = si; &#125;//构造函数,内部为变量赋值 public void check() &#123;//单纯检测simple是否已经创建. if(simple == null) System.out.println("simple is not initlized"); else System.out.println("simple is initlized"); &#125; private Simple lazy() &#123;//检测simple是否已经创建,如果没有创建就创建一个 if(simple == null) &#123; System.out.println("simple is creating"); simple = new Simple(s); &#125; return simple; &#125; public Simple getSimple() &#123;//获取simple的值 return lazy(); &#125; public void setSimple(String sNew) &#123;//设定simple的值 lazy().setString(sNew); &#125; public String toString() &#123; //复写tosring()方法,输出 return lazy().toString(); &#125;&#125;public class testLazy &#123; public static void main(String[] args) &#123; Second second = new Second("intit String"); second.check(); //输出:simple is not initlized //同时为second类中的变量s赋值为:s="intit String" System.out.println(second.getSimple()); //创建simple,为simple赋值:simple="intit String" //输出:simple is creating // intit String second.check(); //输出:simple is initlized second.setSimple("New String"); //输出:intit String System.out.println(second); //输出:New String &#125;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA的静态变量、静态方法、静态类]]></title>
    <url>%2F2017%2F11%2F09%2FStatic-in-Java%2F</url>
    <content type="text"><![CDATA[静态变量和静态方法都属于静态对象，它与非静态对象的差别需要做个说明。 1、Java静态对象和非静态对象有什么区别？比对如下： 非静态对象 静态对象 拥有属性 是类共同拥有的 是类各对象独立拥有的 内存分配 内存空间上是固定的 空间在各个附属类里面分配 分配顺序 先分配静态对象的空间 继而再对费静态对象分配空间，也就是初始化顺序是先静态再非静态 java静态对象到底有什么好处？A，静态对象的数据在全局是唯一的，一改都改。如果你想要处理的东西是整个程序中唯一的，弄成静态是个好方法。 非静态的东西你修改以后只是修改了他自己的数据，但是不会影响其他同类对象的数据。 B，引用方便。直接用 类名.静态方法名 或者 类名.静态变量名就可引用并且直接可以修改其属性值，不用get和set方法。 C，保持数据的唯一性。此数据全局都是唯一的，修改他的任何一处地方，在程序所有使用到的地方都将会体现到这些数据的修改。有效减少多余的浪费。 D，static final用来修饰成员变量和成员方法，可简单理解为“全局常量”。对于变量，表示一旦给值就不可修改；对于方法，表示不可覆盖。 2、静态变量、静态方法和静态块通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象（跟类是否有static修饰无关）。 你可以将方法和变量都声明为static。static 成员的最常见的 例子是main( ) 。声明为static的方法有以下几条限制（main也是？？）： A，它们仅能调用其他的static 方法B，它们只能访问static数据C，它们不能以任何方式引用this 或super(this涉及到对象，super 与继承有关） 示例：Static 块仅在该类被加载时执行一次。下面的例子显示的类有一个static方法，一些static变量，以及一个static 初始化块。1234567891011121314151617public class TestNew &#123; static int a = 3; static int b; static void meth(int x)&#123; System.out.println("x = "+x); System.out.println("a = "+a); System.out.println("b = "+b); &#125; static &#123; System.out.println("static block initialized"); b = a*4; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub meth(42); &#125; &#125; 执行结果是：static block initializedx = 42a = 3b = 12 上述class TestNew的执行顺序是：首先static 块执行(打印一条消息)，a被设置为3，最后b被初始化为a*4 成12。然后调用main()，main () 调用meth() ，把值42传递给x。3个println ( ) 语句引用两个static变量a和b，以及局部变量x 。 3、外部使用静态变量或者静态方法在定义它们的类的外面，static 方法和变量能独立于任何对象而被使用，你只要在类的名字后面加点号运算符即可。可以看到，这种格式与通过对象引用变量调用非static方法或者变量的格式类似。示例： 1234567891011121314class StaticDemo&#123; static int a = 42; static int b = 99; static void callme()&#123; System.out.println("a = "+a); &#125; &#125; public class TestNew &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub StaticDemo.callme(); System.out.println("b = "+StaticDemo.b); &#125; &#125; 执行结果：a = 42b = 99 4、静态内部类是指在一个类的内部，又定义了一个用static修饰的类。可以用C中的结构体内嵌结构体来理解。A，首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。 B，静态方法、静态成员变量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。这样静态内部类就可以理解了，它可以直接被用 外部类名+内部类名 获得。举例如下： 123456789public class Build &#123; .............. public static class VERSION &#123; ................ public static final String RELEASE = getString("ro.build.version.release"); ................ &#125; ................&#125; 在外部可以直接通过Build.VERSION.RELEASE来访问。 参考原文：http://www.cnblogs.com/-0_0-/articles/1962368.html参考原文：http://blog.sina.com.cn/s/blog_5cd7f5b40100r0rt.html参考原文：http://zhidao.baidu.com/question/149873207.html参考原文：http://ddvcxj.blog.51cto.com/1064441/26534]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观西]]></title>
    <url>%2F2017%2F10%2F21%2FEuroTour-Mid2017%2F</url>
    <content type="text"><![CDATA[Het Concertgebouw，当从来不知道中午十一点也能开音乐会的我坐在这家世界三大音响效果最佳的音乐厅之一的RCO主场，拍完照装完逼，准备听一段并不感冒的莫扎特K219，在几乎忽视了这松润甜的混响的确比干涩的国家大剧院高到不知哪里去的事实的同时，一阵雷动的掌声倏忽间将我埋进了齐齐站起的满场垂垂老矣的白发先生当中，生出一阵焦虑。 阿姆斯特丹德奥系目的地偏多的行程里阿姆斯特丹算是奇葩一朵，位列周游列国印象最佳，虽然整座城市大多只是以运河为经脉的老城环状地带以及清一色的联排建筑，大概也是因为荷兰人看上去比傲的要上天的德奥人nice以及从巴黎过去的一路看太多荷兰境内草场看到吐的缘故。搭积木般的小城里人行道有轨电车Tram甚至汽车混搭的交通，且不说两百多米一站的路程时常让你决断不了干脆走路还是花1个多欧去乘Tram，一些小街区出了车门两步路就能迈进一家店的体验可真是住在北京这种出了地铁车厢还要经过少说两段长梯到路面，再走十几分钟才能进家门的人不曾体会到的。 城小，于是文化生活的消息相对容易掌握，爱音乐之人前面的Het Concertgebouw自然不可错过，碰到RCO的演出最好。与之隔一片草地的梵高博物馆，也值得每个爱好者或者像我这般完全连不上平面艺术WiFi的人逛逛，展品不必多说，而从展馆设计到服务到展陈设计到路线几乎是垂直专业类博物馆里的翘楚，导览以及Audioguide也是至今逛到的博物馆里最好用的；可以说除了那本名画集的中文版封面标题排版之外，鲜有槽点。要是上溯到海上霸权的那些事儿，就得荷兰国家博物馆来撑场面了，只是贪多易乱，虽然乱不过卢浮宫，但也要抱着相当的耐心；除了著名打卡地《夜巡》，在日不落帝国都不曾见过如此密集的展现盛极一时的航海时代。 至于De Wallen那边tedious的橱窗长腿妹，放到东方男性oriented的市场里估计要垫底，就连后来的东欧也接受不能，而且被大麻味熏到头疼也并不是多好的体验，曼谷才是你们的福地。大概也因为太过出名，除了运河两边的橱窗，这里的小巷子里挤满了男女老少各色观光客，虽然真的不会有人冲亚洲长相的男性喊“发票”，但也能不时听到国内游客们“她们能有生意么？”的讨论。 维也纳作为德语区第二大城市的维也纳显然要比柏林幸运的多，昔日帝国与王朝的心血并未因战争受损太多，建筑一派雍容华贵，只是在巴黎已经对建筑审美疲劳的我美泉宫美景宫霍夫堡不是没去就是匆匆路过，唯一进过号称混杂各种建筑风格的St. Stephen’s教堂，修葺的影子挡不住本身的巍峨，这几天里唯有布拉格的圣维特可与之一拼。 而发现了艺术史博物馆这块福地绝对是在维也纳最大的惊喜，以“宝石雕刻”为主的装饰艺术不得不让你对这种原本印象中奇技淫巧的花哨玩意儿肃然起敬，简单到金银宝石雕刻的华贵器具，复杂到拟生物座钟及天文钟，远到埃及纸莎草死者之书，近到文具水晶这些科学启蒙时代的产物，远比伦敦的VA及大英的装饰艺术馆好看。 更不用说二层这种“课本名画”堆的到处都是，卡拉瓦乔、勃鲁盖尔、鲁本斯每个人都能挂一屋子的地方了。 艺术史博物馆与对面的自然史博物馆，是特雷西亚广场两侧几乎相同的两栋建筑，一个收藏了最多的宝石雕刻，一个收藏了最多的陨石和矿藏（大概也是最多的鹦鹉螺壳…）。一层鳞次栉比分布着各色矿藏，其中的衍生晶体除了让你感叹自然之无限诡谲之外别无他念，二楼的脊椎动物标本就比较无趣和常见；整体来说矿藏化石和陈年标本值得一逛，假如你对泡了两百多年的带状绦虫之类的奇葩展品感兴趣的话。首先不要被3000万件藏品的简介吓到，因为大概那几百只蚂蚁跟几百只瓢虫就能贡献好几个百分点…… 名声在外的金色大厅不常遇得上维也纳爱乐的演出，更多的是到处都有兜售的不知名乐团的旅游团曲目音乐会，还好我也不听施特劳斯……倒是临时起意跑去国家歌剧院碰碰站票的运气，第一次Opera的经历就这么3个欧贱卖了出去，歌剧院虽老却也为了照顾各国观众几乎每个座位都有不同语言的字幕提词器，然而还是在听完熟悉的第一幕配乐之后不可避免的逃了出去。德奥观众的严谨在于他绝对会群起而厉声制止那些意不在演出却有意无意制造噪音的人。 巴黎巴黎的沉淀是能直接把所有装逼的心态打回原形的地方，作为两个领域的纯小白，当你不知道该从历史开始看起还是城市建筑史开始看起的时候，就只是想哭。被奥斯曼新古典主义的中产阶级石砌建筑重重包围了两天的行程，也就依稀记得卢浮宫的乱，奥赛的莫奈，埃菲尔的小和圣母院全程懵逼的弥撒。 高潮出现在铁塔旁边的河畔博物馆Musée du Quai Branly，藏品多来自处在世界边缘的亚非拉和大洋洲；古希腊罗马雕塑再多，能见到的也大都是高度拟人化的风格，就算是怪力乱神也得尽量安个人的样子；土著先民可不管这一套，一路下来直感叹所谓“文明社会”想象力之匮乏。 萨尔茨堡多年以前受古典乐荼毒不深尚在新粉丝狂热时候留下了这样的豆瓣签名“老了能在萨尔茨堡的山下湖前有个小屋，每天走在街上就能听到巴赫”，能不能有个小屋两说，小城南边阿尔卑斯北麓以及去往维也纳的一路倒是林立各种精致的木屋建筑，但估计每天走在街上听到的只能是各种语言的旅游团喇叭声了。幸好不是在萨尔茨堡音乐节到此，或者在琉森音乐节去琉森，得见这种小城的本来面目只能以无聊概括，论景点恨不得全城一天可以逛两次，对于一个从城中心的酒店走着就能去中央车站的“城市”，生活一个月大概就能逛遍和吃遍所有的店了吧。 布拉格，没什么意思，Communism害死人。 FYI：“说走就走”其实对于欧洲是个不小的挑战，时常会让你面临房少车少而人多的状况，比如提前几个月能比提前几天便宜两三倍的火车票，幸好我这种辞职流浪时间重要不过钱包的时候也有便宜到不行的跨国巴士可以选择，无论是巴黎往阿姆斯特丹的Euroline、德国主营周边的Flixbus、捷克主营的Regiojet都是除了时间之外完全不输火车的体验；不过巴士跑高速，火车钻山，后者风景常会好过前者；然而并非高铁的大多数线路真的很难让你找到时间上的优势。至于房，除非太穷或者酒店一间不剩，还是不要住民宿这种东西了。 妨碍一时冲动的还有比语言更难懂的各国市内交通，已经无力吐槽，对于布拉格这种最糟糕的城市还是早日买24小时票保命，免得满地找售票机甚至假如身上还没有合适的硬币克朗；反正除了逃票之外完全找不到日本那种往售票机里无脑扔一把硬币一秒钟收到找零的快感。 莱比锡差点忘了巴赫爸爸。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>欧洲</tag>
        <tag>博物馆</tag>
        <tag>KHM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观东]]></title>
    <url>%2F2017%2F10%2F08%2FJapan-Early2017%2F</url>
    <content type="text"><![CDATA[人大概在这两种时候会心生忐忑，见自己初喜欢的人，和见自己喜欢过的未知，后者如日本。 该怎么形容“我与日本”这样的话题呢？始终到临走前，我还是没想好的哇。而且总是会想起跟过去有关的事。你的童年与她有关，你的梦想与她有关，你对世界的幻想与她有关，你对爱情的期望与她有关，你的成人礼都与她有关，这么多角色扭打在一起的时候，忐忑就更悠远绵长起来。 大阪价值观如我这般摇摆的人就不应该在去关西前先入为主的听了《日谈公园》，主播菌口中的大农村的印象就那么结实的印到了大阪的首日里；且不说爱彼迎的小屋再一次让人咬牙切齿的痛恨了一回摄影师这个职业（不过也倒是目前见过设施最全的民宿了喂），心斋桥这种小商品一条街也实在让人提不起兴趣，任你优衣库的整栋楼再多可以逛，药妆店吆喝中文的姑娘们再好看，也只是喜欢躲到河边排个一兰拉面尝试一下各种软硬面条和汤底的搭配。 对于一个ぜんぜん弄不懂织田信长丰臣秀吉德川家康谁创业谁守业的人来说，天守城这种大阪为数不多的景点也是百无聊赖，好在旁边就是大阪历史博物馆，在经历了跟基本听不懂英语的接待比划半天我到底该不该存包然后干脆趁那个难缠的人不在溜了进去之后，不得不说总算是找到了抵日两天的精神寄托；硬货不多，要不也不会满是中国都唐了日本同期还是以为属于绳纹弥生时代的陶罐之类的东西；不过日本人的精致还是在还原江户生活的模型里体现的淋漓尽致，比南博负一层的民国时代大模型们难做多了…… 打定主意不怎么做攻略的我提前一个周才知道买了买电话卡跟地铁票，遗憾是错过了东京的三鹰吉卜力这个需要提前一月订票的情怀之地，但惊喜也是有的，梅田就是第一个。说来也巧，在那个有百八十个出口的站把我绕晕之前，捡了个百货商场出口的门就夺门而逃了，路遇现在才知道曲风叫做neo soul的band，看在keyboard姑娘美，哦不，是好听而且还是少见的不是solo的份上，现场不失所望的越来越燃，至少听起来比买回来的拘谨的录音室CD张狂的多，所以谁会说未来Live不是比Record更好更有发展的音乐形式呢？嗯已经在打FUJI ROCK的主意了。 京都真正爱上日本也是从京都开始的吧。当然还是不太推荐在游客高峰期去岚山这种地方，必然是满脑子WTF的怀疑这是个假日本……攻略都是骗人的……要不是有抹茶冰淇淋的拯救，大概对京都的印象也不会好。 踩了踩岚山的竹林，并且没看懂周总理写的是什么诗，小火车回到住地四条大宫的时间还早，折转就去了八坂神社圆山公园二年坂，然后就在四条出口和公园见识了日本人都是怎么卖艺的……大叔拿把破琴指弹玩儿的再认真点就赶上押尾了，而另一位大叔的乐器是两万多的手碟，真是不知道给多少钱合适啊。 第二日的雨让原本金阁寺银阁寺各种寺伏见稻荷打卡一日游的计划被打乱，跑去京都博物馆的室内临时躲雨行程也因为傲娇的非闭馆日闭馆而只花门票的价格参观了一个庭院终结。在纠结总不至于为了一点小雨就牺牲一天住宿费的时候，还是强忍着坐电车去扫一个景点算一个，那就伏见稻荷吧。 虽然没见过阳光嶙峋的千鸟居，但雨中同样流连。伏见稻荷的鸟居漫山遍野，如果你挤不过山脚下围住它们拍照的游客们，山上一点儿不输于此，无论体量还是规模；当然半腰下山的一段奉满了各路神像，要是再有点儿阴天，大概走着就会怕会不会像千寻的爸妈一样被抓去变成猪。 除了文保原因的电车不多，店家关门过早也是不小的困扰，想来八坂神社以上的二年坂三年坂入夜挑灯应该是蛮迷离隔世的一番景色，奈何天一擦黑就纷纷收摊，简直是让人羡慕嫉妒恨的日落而息的生活状态。 总之这是个遗憾大过惊喜的地方，换句话说还对它有绵延不止的期待，比如没去成金阁寺和没吃成怀石料理，anyway，当在御陵卫外边追着那一线阳光拍影子的时候，大概就决定了以后会去常住的吧。 东京去过伦敦之后，我一直以为，东京大概也是类似的“大城市”，那句“如果你厌倦了伦敦，你就厌倦了生活”大概也能套用到后者身上。谁能不爱东京呢？ 不知是否被贵到吃土的新干线伤了神，反正东京的电车还是再次印证了在日本的几天依然没弄懂铁路系统的问题；在出东京站出了半小时、转大手町找了半小时之后，总算找到了去押上的线。好在如此的折腾又换到了一个惊喜，酒店旁边就藏着东京的两家Pokemon Center之一，不由分说抱一只皮卡丘回去是当然的，只是不得不吐槽，除了皮卡丘的等身之外，其他周边还是粗糙，而且一架子不认识的精灵都在冲你说：你老了。 东京的游记至今已经理不出头绪，就像在东京的几天永远没有头绪一样，坐地铁走到哪儿，哪儿都可以玩上半天，计划的落空与补给来的惊喜错综交织，到最后你就早已不记得为玩而玩这件事了。本来的赏樱路线变成了银座那连比弗利和广东道都比不了的大牌林立，本来打个卡就走的早稻田却意外碰上了无法理解的春季毕业季，唯有秋叶原去的符合行程，而那堆成山的手办和小电影真是让人有心无力。 转头说说文化的事，住在押上的另一个好处是，上野就在附近，当然樱花尚不吐蕊的上野恩赐公园并不好玩，而整个上野像柏林的博物馆岛和伦敦特拉法加广场周围一样遍布博物馆，从森美术馆开始，到柯布西耶设计的国立西洋美术馆，到始终没机会进去的自然博物馆，到逛了一天半收藏了规模宏大的植轮跟太刀的最大的东京国立博物馆。 当然六本木偶遇的印度Harsha的Charming Journey展，也比东京塔的夜景有趣，毕竟世界上只有爱情和艺术这两件东西使我们的生活值得苟且。 这样的苗头像极了伦敦四万步的经历，既然肯定有下次，最后一天的行程干脆完全留给了花钱不多的博物馆系列（日本每个博物馆都花钱这很蛋疼），看在上野的那一片离酒店近取行李也方便而且晚上还开的份上就先去了《博物志》里推荐的印刷博物馆。虽然没怎么去过国内的主题博物馆，没得比较，但还是惊叹于展陈的完整性和事无巨细，展品收集上是否丰富有代表性不好评论，毕竟不懂，然而就教学作用来说，完全是白痴看完也能懂的节奏。 出门有每天一节接待六位的印刷体验课，看在人不多的份上尽管不怎么懂日语我还是抱着看展的余热排在门口，奈何半天才找出一位会英语的能交流的叫やまだ的小姑娘，全程被特殊对待并且拿据说是40年代的英产手动活字印刷机印了七张写我名字的信笺而告终。 其他，且不说服务与清洁程度，就是自动化程度之高，也是去过的其他发达国家都无法企及的，路边随处可见的自动贩卖机几乎永远有冷饮热咖啡（似乎厂牌还分的很明显，三得利的机器永远只有旗下的各式咖啡，朝日的机器啤酒居多，伊右卫门的机器自然是热茶居多，其他不知名的则提供各种品牌的小甜水），一兰（要是不等位的话）和松屋这样的快餐以及京都车站的拉面一条街几乎靠自动点餐机就能解决问题，永远提供中日韩英四国语言，酒店的自动洗衣烘干状态能显示到客房电视上，社区也总有自动洗衣门店，就连东京国立博物馆的门票都是自动投币买，车站的精算机也是个神奇的东西。 能在这样一个不需要见人说人话见鬼说鬼话的地方，不愁吃不愁喝，有温暖的周末，做个平凡人没什么不好。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>大阪</tag>
        <tag>东京</tag>
        <tag>京都</tag>
      </tags>
  </entry>
</search>
